"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const python_shell_1 = require("python-shell");
class PythonEvaluator {
    /**
     * starts pythonEvaluator.py
     * @param {string} pythonPath the path to run python. If null python-shell will determine this for you.
     * @param {[string]} pythonOptions see https://docs.python.org/3/using/cmdline.html#miscellaneous-options.
     */
    constructor(pythonPath = null, pythonOptions = ['-u']) {
        this.pythonPath = pythonPath;
        this.pythonOptions = pythonOptions;
        /**
         * whether python is busy executing inputted code
         */
        this.evaling = false;
        /**
         * whether python backend is on/off
         */
        this.running = false;
        this.restarting = false;
        this.pythonEvalFolderPath = __dirname + '/python/';
        /**
         * delays execution of function by ms milliseconds, resetting clock every time it is called
         * Useful for real-time execution so execCode doesn't get called too often
         * thanks to https://stackoverflow.com/a/1909508/6629672
         */
        this.debounce = (function () {
            let timer = 0;
            return function (callback, ms, ...args) {
                clearTimeout(timer);
                timer = setTimeout(callback, ms, args);
            };
        })();
        if (process.platform == "darwin") {
            //needed for Mac to prevent ENOENT
            process.env.PATH = ["/usr/local/bin", process.env.PATH].join(":");
        }
        if (!pythonPath)
            this.pythonPath = python_shell_1.PythonShell.defaultPythonPath;
    }
    /**
     * does not do anything if program is currently evaling code
     */
    execCode(code) {
        if (this.evaling)
            return;
        this.evaling = true;
        this.startTime = Date.now();
        this.pyshell.send(JSON.stringify(code));
    }
    /**
     * @param {string} message
     */
    sendStdin(message) {
        this.pyshell.send(message);
    }
    /**
     * kills python process and restarts.  Force-kills if necessary after 50ms.
     * After process restarts the callback passed in is invoked
     */
    restart(callback = () => { }) {
        this.restarting = false;
        // register callback for restart
        // using childProcess callback instead of pyshell callback
        // (pyshell callback only happens when process exits voluntarily)
        this.pyshell.childProcess.on('exit', () => {
            this.restarting = true;
            this.evaling = false;
            this.start();
            callback();
        });
        this.stop();
    }
    /**
     * kills python process.  force-kills if necessary after 50ms.
     * you can check PythonEvaluator.running to see if process is dead yet
     */
    stop() {
        // pyshell has 50 ms to die gracefully
        this.pyshell.childProcess.kill();
        this.running = !this.pyshell.childProcess.killed;
        if (this.running)
            console.info("pyshell refused to die");
        else
            this.evaling = false;
        setTimeout(() => {
            if (this.running && !this.restarting) {
                // murder the process with extreme prejudice
                this.pyshell.childProcess.kill('SIGKILL');
                if (this.pyshell.childProcess.killed) {
                    console.error("the python process simply cannot be killed!");
                }
                else
                    this.evaling = false;
            }
        }, 50);
    }
    /**
     * starts pythonEvaluator.py. Will NOT WORK with python 2
     */
    start() {
        console.log("Starting Python...");
        this.pyshell = new python_shell_1.PythonShell('pythonEvaluator.py', {
            scriptPath: this.pythonEvalFolderPath,
            pythonOptions: this.pythonOptions,
            pythonPath: this.pythonPath,
        });
        this.pyshell.on('message', message => {
            this.handleResult(message);
        });
        this.pyshell.on('stderr', (log) => {
            this.onStderr(log);
        });
        this.running = true;
    }
    /**
     * Overwrite this with your own handler.
     * is called when program fails or completes
     */
    onResult(foo) { }
    /**
     * Overwrite this with your own handler.
     * Is called when program prints
     * @param {string} foo
     */
    onPrint(foo) { }
    /**
     * Overwrite this with your own handler.
     * Is called when program logs stderr
     * @param {string} foo
     */
    onStderr(foo) { }
    /**
     * handles pyshell results and calls onResult / onPrint
     * @param {string} results
     */
    handleResult(results) {
        let pyResult = {
            userError: "",
            userVariables: {},
            execTime: 0,
            totalTime: 0,
            totalPyTime: 0,
            internalError: "",
            caller: "",
            lineno: -1,
            done: true
        };
        //result should have identifier, otherwise it is just a printout from users code
        if (results.startsWith(PythonEvaluator.identifier)) {
            try {
                results = results.replace(PythonEvaluator.identifier, "");
                pyResult = JSON.parse(results);
                this.evaling = !pyResult['done'];
                pyResult.execTime = pyResult.execTime * 1000; // convert into ms
                pyResult.totalPyTime = pyResult.totalPyTime * 1000;
                //@ts-ignore pyResult.userVariables is sent to as string, we convert to object
                pyResult.userVariables = JSON.parse(pyResult.userVariables);
                if (pyResult.userError != "") {
                    pyResult.userError = this.formatPythonException(pyResult.userError);
                }
                pyResult.totalTime = Date.now() - this.startTime;
                this.onResult(pyResult);
            }
            catch (err) {
                if (err instanceof Error) {
                    err.message = err.message + "\nresults: " + results;
                }
                throw err;
            }
        }
        else {
            this.onPrint(results);
        }
    }
    /**
     * checks syntax without executing code
     * @param {string} code
     * @returns {Promise} rejects w/ stderr if syntax failure
     */
    checkSyntax(code) {
        return __awaiter(this, void 0, void 0, function* () {
            return python_shell_1.PythonShell.checkSyntax(code);
        });
    }
    /**
     * checks syntax without executing code
     * @param {string} filePath
     * @returns {Promise} rejects w/ stderr if syntax failure
     */
    checkSyntaxFile(filePath) {
        return __awaiter(this, void 0, void 0, function* () {
            // note that this should really be done in pythonEvaluator.py
            // but communication with that happens through just one channel (stdin/stdout)
            // so for now i prefer to keep this seperate
            return python_shell_1.PythonShell.checkSyntaxFile(filePath);
        });
    }
    /**
     * gets rid of unnecessary exception data, among other things
     * @param {string} err
     * @example err:
     * "Traceback (most recent call last):
     *   File "pythonEvaluator.py", line 26, in <module>
     * 	exec(data['evalCode'], evalLocals)
     *   line 4, in <module>
     * NameError: name 'y' is not defined"
     * @returns {string}
     */
    formatPythonException(err) {
        //replace File "<string>" (pointless)
        err = err.replace(/File \"<string>\", /g, "");
        // we need to further modify bottom traceback
        let index = err.lastIndexOf("Traceback (most recent call last):");
        let bottomTraceback = err.slice(index);
        let otherTracebacks = err.slice(0, index);
        let errLines = bottomTraceback.split('\n');
        // error caught in pythonEvaluator so it includes that stack frame
        // user should not see it, so remove first and second lines:
        errLines = [errLines[0]].concat(errLines.slice(3));
        bottomTraceback = errLines.join('\n');
        return otherTracebacks + bottomTraceback;
    }
}
PythonEvaluator.identifier = "6q3co7";
exports.PythonEvaluator = PythonEvaluator;
//# sourceMappingURL=index.js.map